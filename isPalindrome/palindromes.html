<h1>Find Palindromes in R</h1>

<h2>Introduction</h2>

<p>
  Hello, and welcome to my code blog! I started this website as a way
  for me to share my coding work publicly. It took a lot of time and messy
  C# code to get here, and I could not be more excited. Now, let`s get
  into palindromes!
</p>

<p>
  A common coding interview task is to write code that tells you
  whether a given string is a palindrome. It is easy to see why: it is a
  great way to showcase knowledge of regular expressions and reshaping
  data. Additionally, I think it`s a great time to introduce the idea of
<a href="https://r-pkgs.org/testing-basics.html">testing</a> in R.</p>

<h2>Testing</h2>
<p>
  Testing is a great way to automate the "spot checks" your code
  has to make sure things are running properly. Since data science 
  and analysis can go unexpected places, it is not always possible
  to implement unit tests for every task. However, I still think they
  are underutilized. For example, I frequently create CSV files with
  a series a regular expressions I want to evaluate. When I add to that
  list, unit tests make it easy to ensure I'm not breaking previously-written 
  code. Good code is consistent and accurate. Please do not give me
  research assignments in the middle of your code! If you feel the need to
  check the results at each run, that`s a good sign the code is not ready
  yet. In this post, we will be using <a href="https://testthat.r-lib.org/">testthat</a> 
  to implement unit testing. testthat is mostly built for package development, 
  but now is a good time to introduce it. Plus, it has some features built in
  to make unit testing a little more fun.
</p>

<h2>Palindromes: Setting up tests</h2>
<p>
  Next, let`s set up our test cases. Some Googling brought me to <a href="http://www.palindromelist.net/">palindromelist.net</a>. I noticed
  that punctuation and capitalization are disregarded in these lists. For
  this blog, I will assume that only the letters of the alphabet matter in
  determining whether or not a word is a palindrome. Let`s use a sample of
  entries from the website to test our palindrome function. We also want
  to make sure the function correctly identifies words that are NOT
  palindromes, so let`s add in a test for words that should return FALSE.
  Finally, if the supplied value is not a character vector, an error
  should be returned.
</p>

<pre class="r"><code>
library(testthat)

# Start with writing unit tests!
run_tests &lt;- function(myfun) {

# These should all return TRUE
test_that(&#39;Works on real palindromes&#39;, { # If a test fails, this prints
  palindromes &lt;- c(
    &#39;kayak&#39;, &#39;deified&#39;, &#39;rotator&#39;, &#39;repaper&#39;, &#39;deed&#39;, &#39;peep&#39;, 
    &#39;wow&#39;, &#39;noon&#39;, &#39;civic&#39;, &#39;racecar&#39;, &#39;level&#39;, &#39;mom&#39;, 
    &#39;bird rib&#39;, &#39;taco cat&#39;, &#39;UFO tofu&#39;, &#39;Borrow or rob?&#39;, 
    &#39;Never odd or even.&#39;, &#39;We panic in a pew.&#39;, 
    &#39;Won`t lovers revolt now?&#39;,  
    &#39;Ma is a nun, as I am.&#39;, &#39;Don`t nod.&#39;, 
    &#39;Sir, I demand, I am a maid named Iris.&#39;, 
    &#39;Was it a car or a cat I saw?&#39;, &#39;Yo, Banana Boy!&#39;, 
    &#39;Eva, can I see bees in a cave?&#39;, 
    &#39;Madam, in Eden, I`m Adam.&#39;, 
    &#39;A man, a plan, a canal, Panama!&#39;, 
    &#39;Never a foot too far, even.&#39;,
    &#39;Red roses run no risk, sir, on Nurse`s order.&#39;, 
    &#39;He lived as a devil, eh?&#39;, &#39;Ned, I am a maiden.&#39;, 
    &#39;Now, sir, a war is won!&#39;, &#39;Evade me, Dave!&#39;, 
    &#39;Dennis and Edna sinned.&#39;, &#39;Step on no pets!&#39;, &#39;Ã¤Ã¤&#39;)
funx &lt;- myfun
expect_equal(myfun(palindromes), rep(TRUE, length(palindromes)))
})

# Ensure it returns False when it should
test_that(&#39;Works on non-palindromes&#39;, {
  antipalindromes &lt;- c(&#39;cat&#39;, &#39;dog&#39;, &#39;Mustard&#39;, &#39;&#39;, character(0))
  expect_equal(myfun(antipalindromes), rep(FALSE, length(antipalindromes)))
})

# Make sure error is thrown if non-character used
test_that(&#39;Error if not character&#39;, {
  expect_error(myfun(12))
  expect_error(myfun(NULL))
  expect_error(myfun(FALSE))
  expect_error(myfun(Sys.Date()))
})
}
</code></pre>
<p>
  Note the function names that read like English. It`s one of the many
  nice things about the testthat package. Typically, in package
  development, you would store all of your tests in the
  <code>mypackage/tests/testthat</code> directory. Above, we placed all
  unit tests in a single <code>run_tests()</code> function. This is for
  convenience and to allow testing and function writing to happen in a
  single script.
</p>

<p>
  Before we move on to writing a function, let`s take a step back and
  think about all of the benefits of writing these tests. The simple act
  of gathering some test cases made us think about the things that make
  this `easy` task hard: capitalization, spaces, punctuation, and empty
  strings to name a few. I will confess, my first version of this function
  would have failed on the of the 4 pitfalls I just mentioned. I`m glad I
  finally took the time to step back and write good tests!
</p>
<div id="function-is_palindrome" class="section level2">
<h2><strong>Function is_palindrome</strong></h2>
<pre class="r"><code>
# Write a function to determine whether a particular word is a palindrome
is_palindrome &lt;- function(word){
# Check that a character input was provided
  if(!is.character(word)){
    stop(&#39;That is not valid input. Please try again.&#39;)
  }
  
  # Strip out non-alpha characters, convert to lower case, check equivalency
  newword &lt;- tolower(gsub(&#39;\\W&#39;, &#39;&#39;, word))
  rev_words &lt;- do.call(c, 
                       lapply(newword, 
                              function(x) {
                                paste(rev(strsplit(x, NULL)[[1]]), 
                                      collapse = &#39;&#39;)
                                }
                              ))
  out &lt;- tolower(newword) == tolower(rev_words)
  out[which(newword == &#39;&#39;)] &lt;- FALSE
  return(out)
}


# Try it out on a few samples
is_palindrome(c(&#39;Jon&#39;, &#39;apple&#39;, &#39;sos&#39;))
</code></pre>

<pre><code>## [1] FALSE FALSE  TRUE</code></pre>

<pre class="r"><code>
# And run our comprehensive testing function from above!
run_tests(is_palindrome)
</code></pre>

<pre><code>
## Test passed ðŸ¥‡
## Test passed ðŸ˜¸
## Test passed ðŸ˜¸
</code></pre>

<p>
  And there you have it! A vectorized, flexible function to identify
  palindromes, all ready to go. Well, almostâ€¦we forgot about characters
  not in the English alphabet! I won`t pretend to know any foreign
  languages (I`m barely literate in English and R), but it would at least
  be nice for it to work in other languages in theory. Perhaps a new test
  might look something like:
</p>
<pre class="r"><code>
# A lazy example, I will admit
library(waldo) # For foreign characters
</code></pre>

<pre><code>
## Warning: package &#39;waldo&#39; was built under R version 4.2.1
## 
## Attaching package: &#39;waldo&#39;
## The following object is masked from &#39;package:testthat&#39;:
##     compare
test_that(&#39;Non-english characters are okay&#39;,
          expect_true(is_palindrome(&#39;Ã¤Ã¤&#39;)))
## Test passed ðŸŒˆ
</div>


<style>
  code {
    color: black;
  }
  pre {
    background-color: whitesmoke;
  }
</style>